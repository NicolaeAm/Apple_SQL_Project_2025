-- DROP TABLE command
--DROP TABLE IF EXISTS warranty;
--DROP TABLE IF EXISTS sales;
--DROP TABLE IF EXISTS products;
--DROP TABLE IF EXISTS category;
--DROP TABLE IF EXISTS stores;)

-- CREATE TABLE commands

CREATE TABLE stores(
store_id VARCHAR(5) PRIMARY KEY,
store_name	VARCHAR(30),
city	VARCHAR(25),
country VARCHAR(25)
);

DROP TABLE IF EXISTS category;
CREATE TABLE category
(category_id VARCHAR(10) PRIMARY KEY,
category_name VARCHAR(20)
);

CREATE TABLE products
(
product_id	VARCHAR(10) PRIMARY KEY,
product_name	VARCHAR(35),
category_id	VARCHAR(10),
launch_date	date,
price FLOAT,
CONSTRAINT fk_category FOREIGN KEY (category_id) REFERENCES category(category_id)
);

CREATE TABLE sales
(
sale_id	VARCHAR(15) PRIMARY KEY,
sale_date	DATE,
store_id	VARCHAR(10), -- this fk
product_id	VARCHAR(10), -- this fk
quantity INT,
CONSTRAINT fk_store FOREIGN KEY (store_id) REFERENCES stores(store_id),
CONSTRAINT fk_product FOREIGN KEY (product_id) REFERENCES products(product_id)
);

CREATE TABLE warranty
(
claim_id VARCHAR(10) PRIMARY KEY,	
claim_date	date,
sale_id	VARCHAR(15),
repair_status VARCHAR(15),
CONSTRAINT fk_orders FOREIGN KEY (sale_id) REFERENCES sales(sale_id)
);

-- Apple Project - Over 1M rows sales dataset.

SELECT * FROM category;
SELECT * FROM products;
SELECT * FROM sales;
SELECT * FROM stores;
SELECT * FROM warranty;

--EDA 

SELECT DISTINCT repair_status FROM warranty;
SELECT COUNT(*) FROM sales;

--Improving Query Performance
--ET = 139.8 MS
--PT = 0.08 MS
--ET after index 5-10 MS
EXPLAIN ANALYZE
SELECT * FROM sales
WHERE product_id = 'P-44';

CREATE INDEX sales_product_id ON sales(product_id);


--Improving Query Performance
--ET = 0.16 MS
--PT = 0.14 MS
--ET after index 0.04 MS
EXPLAIN ANALYZE
SELECT * FROM sales
WHERE product_id = 'ST-31';

CREATE INDEX sales_store_id ON sales(store_id);

--1. Find the number of store in each country.

SELECT
	count(*) AS total_stores,
	country
FROM stores
GROUP BY country
ORDER BY 1 DESC;

--2.Find the total revenue generated by each contry.

SELECT
	st.country,
	SUM(s.quantity * p.price) AS total_revenue
FROM sales AS s
JOIN 
products AS p
ON s.product_id = p.product_id
JOIN 
stores AS st 
ON s.store_id = st.store_id
GROUP BY 1
ORDER BY 2 DESC;

--3 Find the total quantity of each product category sold in 2023

SELECT 
	c.category_name,
	SUM(s.quantity) AS total_units_sold
FROM sales AS s
JOIN products AS p
ON s.product_id = p.product_id
JOIN category AS c
ON p.category_id = c.category_id
WHERE 
	EXTRACT(YEAR FROM s.sale_date) = 2023
GROUP BY 1 
ORDER BY 2 DESC

--4.Determine how many stores have never had a warranty claim filed.

SELECT 
	COUNT(*) AS no_claims
FROM stores
	WHERE store_id NOT IN (
						SELECT
							DISTINCT store_id
						FROM sales AS sl 
						RIGHT JOIN warranty as wr
						ON sl.sale_id = wr.sale_id)
						;

--5.Calcualte the total number of warranty calims filed per month in 2023.

SELECT
	EXTRACT(YEAR FROM claim_date) AS claim_year,
	TO_CHAR(claim_date, 'Mon') AS claim_month,
	COUNT(claim_id) AS tot_claims
FROM warranty
WHERE EXTRACT(YEAR FROM claim_date) = 2023
GROUP BY 1,2
ORDER BY 1

--6. Calculate the percentage of the total warranty claims marked.

SELECT
    repair_status,
    ROUND(COUNT(claim_id)/(SELECT COUNT(*)FROM warranty)::numeric 
	* 100, 2) AS total_claims
FROM warranty
GROUP BY 1
;

--7. Identify the top 5 best-performing stores by total revenue.

SELECT 
    st.store_id,
    st.store_name,
    st.country,
    SUM(s.quantity * p.price)  AS total_revenue
FROM sales AS s
JOIN products AS p 
    ON s.product_id = p.product_id
JOIN stores AS st 
    ON s.store_id = st.store_id
GROUP BY 1, 2, 3 
ORDER BY 4 DESC
LIMIT 5;


--8 List top 5 products with the highest total units sold across all stores.

SELECT
    p.product_id,
    p.product_name,
    SUM(s.quantity) AS total_units_sold
FROM sales AS s
JOIN products AS p 
ON s.product_id = p.product_id
GROUP BY 1, 2
ORDER BY 3 DESC
LIMIT 5;

--9. Find the average time between product launch and first sale for each product.

WITH first_sale
AS
	(
		SELECT
			product_id,
			MIN(sale_date) AS first_sale_date
		FROM sales
		GROUP BY 1
	)

SELECT 
	p.product_id,
	p.product_name,
	p.launch_date,
	f.first_sale_date,
	(f.first_sale_date::date - p.launch_date::date) AS days_to_first_sale
FROM products AS p
JOIN first_sale AS f
	ON p.product_id = f.product_id
GROUP BY 1, 2, 4
ORDER BY 5 DESC;

--10. Identify the month with the highest overall sales volume for 2023.


SELECT 
    TO_CHAR(sale_date, 'Month') AS month_name,
    EXTRACT(MONTH FROM sale_date) AS month_number,
    SUM(quantity) AS total_units_sold
FROM sales 
WHERE EXTRACT(YEAR FROM sale_date) = 2023
GROUP BY 1, 2
ORDER BY 3 DESC
;

--11.For each store, identify the best-selling day based on highest quantity sold.

SELECT *
FROM
(SELECT 
	st.country,
	st.store_name,
	s.store_id,
	SUM(s.quantity) AS total_units_sold,
	TO_CHAR (s.sale_date, 'Day') as day_name,
	RANK() OVER(PARTITION BY s.store_id ORDER BY SUM(s.quantity) DESC) AS rating
FROM sales AS s
JOIN stores AS st
	ON s.store_id = st.store_id
GROUP BY 1, 2, 3, 5
)as r
WHERE rating = 1
;


--12. Find the top-selling product category in each country over the last two years.

WITH category_sales AS(
	SELECT
	    st.country,
	    c.category_name,
	    SUM(s.quantity) AS total_units_sold
	FROM sales AS s
	JOIN products AS p
		ON s.product_id = p.product_id
	JOIN category AS c
		ON p.category_id = c.category_id
	JOIN stores AS st
		ON s.store_id = st.store_id 
	WHERE s.sale_date >= (CURRENT_DATE - INTERVAL '2.1 year')
	GROUP BY 1, 2
),
top_selling AS (
	SELECT 
		country,
		category_name,
		total_units_sold,
		RANK() OVER (PARTITION BY country ORDER BY total_units_sold DESC) AS rnk
	FROM category_sales
)
SELECT 
	country,
	category_name,
	total_units_sold
FROM top_selling
WHERE rnk = 1
ORDER BY 3 DESC
;

--13.Determine how many warranty claims were filed for products priced above $1,500

SELECT 
    COUNT(w.claim_id) AS total_claims_above_1500
FROM warranty AS w
JOIN sales AS s 
    ON w.sale_id = s.sale_id
JOIN products AS p 
    ON s.product_id = p.product_id
WHERE p.price > 1500;

--14. Identify the 10 stores with the largest sales decline between 2022 and 2023.

WITH yearly_sales AS (
    SELECT 
        s.store_id,
        EXTRACT(YEAR FROM s.sale_date) AS sale_year,
        SUM(s.quantity * p.price) AS total_revenue
    FROM sales AS s
    JOIN products AS p 
        ON s.product_id = p.product_id
    GROUP BY 1, 2
),
sales_diff AS (
SELECT 
        y22.store_id,
        y22.total_revenue AS revenue_2022,
        y23.total_revenue AS revenue_2023,
        (y23.total_revenue - y22.total_revenue) AS revenue_change
    FROM yearly_sales AS y22
    JOIN yearly_sales AS y23 
        ON y22.store_id = y23.store_id
       AND y22.sale_year = 2022
       AND y23.sale_year = 2023
)
SELECT
	st.store_id,
    st.store_name,
    st.country,
    sd.revenue_2022,
    sd.revenue_2023,
    sd.revenue_change
FROM sales_diff AS sd
JOIN stores AS st 
    ON sd.store_id = st.store_id
ORDER BY sd.revenue_change ASC
LIMIT 10;

--15.List the months in the last three years where sales 
   --exceeded 10,000 units in the USA.

SELECT * FROM
(
SELECT 
	TO_CHAR (sale_date, 'MM-YYYY') AS month,
	SUM(s.quantity) AS total_unit_sold
FROM sales AS s
JOIN 
stores AS st
ON s.store_id = st.store_id
WHERE 
	st.country = 'USA'
	AND
	s.sale_date >= CURRENT_DATE - INTERVAL '4.1 year'
GROUP BY 1
) AS ta

WHERE total_unit_sold >= 10000;


--16. Analyze the relationship between sales volume and claim frequency per product (correlation).

WITH product_sales AS (
    SELECT
        product_id,
        SUM(quantity) AS total_quantity
    FROM
        sales
    GROUP BY 1
),
product_claims AS (
    SELECT
        s.product_id,
        COUNT(w.claim_id) AS claim_count
    FROM warranty AS w
    JOIN sales AS s 
	ON w.sale_id = s.sale_id
    GROUP BY 1
),
product_metrics AS (
    SELECT
        COALESCE(ps.product_id, pc.product_id) AS product_id,
        COALESCE(ps.total_quantity, 0) AS total_quantity,
        COALESCE(pc.claim_count, 0) AS claim_count
    FROM product_sales AS ps
    FULL OUTER JOIN product_claims AS pc
		ON ps.product_id = pc.product_id
)
SELECT
    ROUND(CORR(total_quantity, claim_count)::numeric, 4) AS sales_claims_correlation
FROM
    product_metrics
WHERE
    total_quantity > 0 OR claim_count > 0;


--17. Analyze the year-by-year growth ratio for each store

WITH yearly_sales
AS
(
	SELECT 
		s.store_id,
		st.store_name,
		EXTRACT (YEAR FROM sale_date) as year,
		SUM(s.quantity * p.price) AS total_sales
	FROM sales AS S
	JOIN products AS p
	ON s.product_id = p.product_id
	JOIN stores AS st
	ON st.store_id = s.store_id
	GROUP BY 1, 2, 3
	ORDER BY 2, 3
),
growth_ratio
AS
(
SELECT 
	store_name,
	year,
	LAG(total_sales, 1) OVER(PARTITION BY store_name ORDER BY year) AS last_year_sale,
	total_sales as current_year_sale
FROM yearly_sales
)
SELECT 
	store_name,
	year,
	last_year_sale,
	current_year_sale,
	ROUND(
	(current_year_sale - last_year_sale)::numeric/last_year_sale::numeric * 100
	,2) growth_ratio
FROM growth_ratio 	
WHERE last_year_sale IS NOT NULL
	AND 
	YEAR <> EXTRACT(YEAR FROM CURRENT_DATE)

--18. Find the average revenue per claim across all stores.

WITH claim_revenue AS (
    SELECT
        w.claim_id,
        s.store_id,
        (s.quantity * p.price) AS revenue
    FROM warranty AS w
    JOIN sales AS s 
	ON w.sale_id = s.sale_id
    JOIN products AS p 
	ON s.product_id = p.product_id
),
store_avg_revenue AS (
    SELECT
        clr.store_id,
        st.store_name,
        SUM(clr.revenue) / COUNT(clr.claim_id) AS avg_revenue_per_claim_store
    FROM claim_revenue AS clr
    JOIN stores AS st 
	ON clr.store_id = st.store_id
    GROUP BY 1, 2 
),
overall_metrics AS (
    SELECT
        AVG(avg_revenue_per_claim_store) AS overall_avg_revenue_per_claim,
        -- STDDEV_POP is used for population standard deviation across all store averages
        STDDEV_POP(avg_revenue_per_claim_store) AS stddev_avg_revenue_per_claim
    FROM
        store_avg_revenue
)
SELECT
    sar.store_id,
    sar.store_name,
    ROUND(sar.avg_revenue_per_claim_store::numeric, 2) AS store_avg_revenue_per_claim,
    ROUND(om.overall_avg_revenue_per_claim::numeric, 2) AS overall_avg_revenue_per_claim,
    ROUND(((sar.avg_revenue_per_claim_store - om.overall_avg_revenue_per_claim) / om.stddev_avg_revenue_per_claim)::numeric, 2) AS z_score,
    CASE
        WHEN ABS((sar.avg_revenue_per_claim_store - om.overall_avg_revenue_per_claim) / om.stddev_avg_revenue_per_claim) > 2 THEN ' Outlier Store'
        ELSE 'Normal'
    END AS outlier_status
FROM
    store_avg_revenue sar
CROSS JOIN
    overall_metrics om 
ORDER BY
    outlier_status DESC, store_avg_revenue_per_claim DESC;

--19. Calculate the 12-month rolling average of sales for each product category to smooth trends.

WITH monthly_category_sales AS (
    SELECT
        DATE_TRUNC('month', s.sale_date) AS sale_month,
        c.category_name,
        SUM(s.quantity) AS monthly_sales_quantity
    FROM sales AS s
    JOIN products AS p 
	ON s.product_id = p.product_id
    JOIN category AS c 
	ON p.category_id = c.category_id
    GROUP BY
        1, 2
)
SELECT
    sale_month::date,
    category_name,
    monthly_sales_quantity,
    ROUND(
	        AVG(monthly_sales_quantity) OVER (PARTITION BY category_name
	        ORDER BY sale_month
	        ROWS BETWEEN 11 PRECEDING AND CURRENT ROW
	        )::numeric, 2
        ) AS rolling_12_month_avg_quantity
FROM
    monthly_category_sales mcs
ORDER BY 1, 2
   

--20. Determine which country shows the strongest seasonality pattern in sales (using monthly averages).Â 

WITH monthly_country_sales AS (
    SELECT
        st.country,
        TO_CHAR (sale_date, 'MM-YYYY') AS sale_month,
        SUM(s.quantity) AS monthly_sales_quantity
    FROM sales AS s
    JOIN stores AS st 
	ON s.store_id = st.store_id
    GROUP BY
        1, 2
)
SELECT
    country,
    ROUND(AVG(monthly_sales_quantity)::numeric, 2) AS average_monthly_sales,
    ROUND(STDDEV_POP(monthly_sales_quantity)::numeric, 2) AS stddev_monthly_sales,
    ROUND((STDDEV_POP(monthly_sales_quantity) / AVG(monthly_sales_quantity)
        ) * 100::numeric, 2
    ) AS coefficient_of_variation
FROM
    monthly_country_sales 
GROUP BY
    1
HAVING
    AVG(monthly_sales_quantity) IS NOT NULL AND AVG(monthly_sales_quantity) > 0
ORDER BY
    coefficient_of_variation DESC;





